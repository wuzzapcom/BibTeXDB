\section*{Разработка серверного приложения}
\addcontentsline{toc}{section}{Разработка серверного приложения}

Приложение написано на языке Go, его можно разделить на несколько модулей или пакетов, что и было сделано
в исходном коде программы. 

В первую очередь стоит отметить пакет \texttt{fetcher}, который отвечает за
поиск книг в сервисе Google Books. Он формирует запрос с помощью API-ключа и данных,
введенных пользователем, после чего отправляет его и получает ответ, а дальше возвращает его в необходимом
формате. Именно по этой причине для старта приложения необходимо вводить API-ключ.

Далее следует, пожалуй, самая крупная часть данного приложения: работа с базой данных. Как уже было упомянуто
выше, работа с ней ведется с использованием связки из модуля стандартной библиотеки \texttt{database/sql} и
драйвера \texttt{pq}. Пакет \texttt{database/sql} является исключительно интерфейсом, в то время как именно
драйвер реализует всю необходимую логику. Для их взаимодействия нужно добавить в файл оба этих пакета, используя команду
\texttt{import}.

Для начала будет правильным рассмотреть принципы работы с \texttt{database/sql}.
Подключение к СУБД происходит с помощью метода \texttt{sql.Open}.
Данный метод имеет два параметра:

\begin{itemize}
	\item имя драйвера -- в данном случае это будет postgres,
	\item конфигурационная строка -- набор пар ключ-значение, определяющее все параметры подключения. Например,
	      подключение к базе данных <<bibtex>> пользователя <<username>> к СУБД, находящейся на порту 8888, будет выглядеть
	      следующим образом: \texttt{"user=username port=8888 dbname=bibtex"}.
\end{itemize}

Метод \texttt{sql.Open} вернет структуру \texttt{sql.DB}, через которую будут происходить
все дальнейшие взаимодействия с СУБД, в частности, внесение и получение данных.

Следующим шагом стоит выполнить метод \texttt{DB.Ping}, который создает или восстанавливает подключение.
Это позволяет удостовериться, что все работает корректно. После этого СУБД готова к использованию в приложении.

В первую очередь при разработке были реализованы методы \texttt{insert} и \texttt{select} для всех таблиц.
Стоит отметить, что приложение рассчитано исключительно на использование из CLI и веб-приложения и не
предусматривает вставки нескольких записей за раз. \texttt{Select} внутри запроса сразу выполняет
необходимые объединения \texttt{join} для того, чтобы результат был максимально удобен для
использования пользователем.

Следующим шагом были разработаны методы для удаления из таблиц. Как уже было сказано выше,
было решено использовать каскадное удаление на стороне сервера. Для этого были использованы
транзакции. В пакете \texttt{database/sql} они представляются структурой \texttt{Tx}.
Если начинать использовать транзакции в удалении, то было бы логично начать использовать их везде, в том числе
и уже реализованных \texttt{insert} и \texttt{select}. Для этого был создан интерфейс языка Go, который можно увидеть в листинге ~\ref{sqlexecutable}.

\begin{lstlisting}[language=bash, caption = {Интерфейс унификации транзакций.}, captionpos=b, label={sqlexecutable}]
type SQLExecutable interface {
	Exec(string, ...interface{}) (sql.Result, error)
	Query(string, ...interface{}) (*sql.Rows, error)
	QueryRow(string, ...interface{}) *sql.Row
}
\end{lstlisting}

Этот интерфейс необходим для унификации используемых методов структур \texttt{sql.DB} и \texttt{sql.Tx}.
С использованием этого интерфейса стало возможно написание метода \texttt{getSQLExecutable}, который
возвращает структуру транзакции, если она была иницилизирована и обычную \texttt{sql.DB} в ином случае.

После этого достаточно все использования \texttt{sql.DB} заменить на метод \texttt{getSQLExecutable}.
Важно отметить, что для использования такого приема не требуется никакого изменения этих структур.
Дело в том, что, в отличии от, например, языка Java, для имплементации интерфейса структуре не
обязательно явно указывать список реализуемых интерфейсов. Компилятор способен сам определять, подходит
ли структура под выбранный интерфейс. В случае неудачи при компиляции будет выведена ошибка.

Теперь можно перейти непосредственно к методам удаления. Принцип их работы прост: в рамках одной
транзакции последовательно удалять все необходимые таблицы. Рассмотрим, например, последовательность действий
при удалении таблицы \texttt{Course}:

\begin{enumerate}
	\item удалить курс и получить список суррогатных ключей затронутых списков литературы,
	\item по суррогатным ключам удалить списки литературы, получить список суррогатных ключей
	      для связи многие-ко-многим с учебниками,
	\item по суррогатным ключам удалить все связи многие-ко-многим.
\end{enumerate}

Аналогично будет происходить со всеми остальными удалениями.

Последней проблемой в этой части приложения стала реализация обновления. Самым логичным поведением тут
является реализация политики <<при \texttt{insert} добавить новую запись, если записи с таким первичным ключом нет, 
обновить в ином случае>>. Это позволяет свести любые обновления к добавлениям, что уменьшает количество
кода и на сервере, и на клиентах. Но возникает проблема с тем, что такая возможность реализована во всех
СУБД немного по разному. Например, в SQLite для таких целей есть отдельная команда \texttt{replace}.
В PostgreSQL есть конструкция <<ON CONFLICT>>. Добавление в таблицу \texttt{Lecturer} с учетом этой конструкции можно
увидеть в листинге ~\ref{insert_lecturer}.

\begin{lstlisting}[language=bash, caption = {SQL запрос добавления записи в таблицу Lecturer}, captionpos=b, label={insert_lecturer}]
INSERT INTO schema.lecturer(
    lecturer_name, 
    lecturer_date_of_birth,
    lecturer_department_id, 
    lecturer_timestamp
    ) 
    VALUES ($1, $2, $3, $4)
        ON CONFLICT(lecturer_name, lecturer_date_of_birth) 
        DO UPDATE SET
            lecturer_department_id=
                EXCLUDED.lecturer_department_id,
            lecturer_timestamp=
                EXCLUDED.lecturer_timestamp,
            lecturer_is_deleted=
                FALSE;
\end{lstlisting}

При отладке этой части программы была обнаружена одна особенность языка Go, которая
сильно усложняет тестирование работоспособности приложения. Дело в том, что тип 
error, являющийся стандартным типом для ошибок, не предоставляет трассировку стека. Другими словами, по ошибке невозможно понять,
в каком месте программы она была вызвана в случае, если обработка этой ошибки делегируется
вызывающему методу. Дело в том, что тип error, которым представляются все ошибки в языке
Go, является всего лишь интерфейсом с одним методом \texttt{Error() string}, возвращающим текст ошибки.
Но, с другой стороны, такой подход позволяет реализовывать собственные типы ошибок,
что и было сделано данном приложении. Ошибка представляется типом \texttt{Error}, который можно увидеть в листинге ~\ref{error}:

\begin{lstlisting}[language=bash, caption = {Стурктура Error.}, captionpos=b, label={error}]
type Error struct {
	Message       string
	StackTrace    string
	DatabaseError *pq.Error
}
\end{lstlisting}

Перечислим назначение каждого поля.

\begin{enumerate}
	\item \texttt{Message} -- текстовое сообщение об ошибке,
	\item \texttt{StackTrace} -- трассировка ошибки, созданная на основе метода \texttt{runtime.Stack} пакета \texttt{runtime},
	\item \texttt{DatabaseError} -- указатель на ошибку драйвера \texttt{pq}, работающего с PostgreSQL. Указатель равен \texttt{nil}
	      в случае, если ошибка произошла не в драйвере.
\end{enumerate}

Теперь следует описать принципы работы программного интерфейса. В разработанном приложении используется HTTP-сервер из стандартной
библиотеки языка Go. Использовать этот пакет очень просто: необходимо добавить необходимый метод с нужной сигнатурой и
URL-строку в сервер с помощью метода \texttt{http.HandleFunc}. В этой сигнатуре функция должна принимать два аргумента:
\texttt{http.ResponseWriter}, который предназначен для отправки ответа клиенту и \texttt{http.Request}, содержащий информацию
о поступившем запросе. В приложении на каждый запрос первым делом выполняется проверка входных данных, если таковые имеются.
По большей части это проверка на наличие тела запроса, если оно должно присутствовать.

Также при обработке каждого запроса в ответ добавляется заголовок \texttt{Access-Control-Allow-Origin}, который необходим
для того, чтобы при использовании этого API браузером все работало корректно. Без этого хэдера браузеры просто блокируют запросы
к серверу. Согласно документации компании <<Mozilla>>\cite{Access-Control-Allow-Origin}, этот заголовок позволяет
установить, с какими сайтами сервер умеет работать, а с какими не умеет. Например, в него можно записать \texttt{https://developer.mozilla.org},
что означает, что сервер умеет работать только с одним этим сайтом. Если значение будет \texttt{*}, тогда сервер будет работать с абсолютно
любым клиентом.

Для каждой таблицы имеется следующий набор методов:

\begin{enumerate}
	\item получение содержимого таблицы,
	\item добавление записи в таблицу,
	\item удаление из таблицы,
	\item получение прототипа JSON-файла для записи таблицы.
\end{enumerate}

Также сервер имеет три дополнительных метода помимо описанной структуры. 
Первый метод выполняет миграцию списка литературы с одного года на другой.
Второй нужен для получения прототипа JSON-файла миграции, а третий выполняет генерацию отчета
и записывает его на клиент в виде текстового файла. В случае веб-версии происходит создание текстового файла в формате \texttt{.bib}, который
сохраняется в загрузки.