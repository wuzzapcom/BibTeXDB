\section*{Обзор}
\addcontentsline{toc}{section}{1 Обзор}

Для любой программы интерфейс является одной из наиболее важных составляющих.
Именно он определяет, как приложение будет взаимодействовать с другими
программами и своими пользователями. Таким образом, можно ввести следующую
классификацию интерфейсов:

\setlist{nolistsep}
\begin{enumerate}
    \item Интерфейсы программирования приложений.
    \item Графические.
    \item Интерфейсы командной строки.
\end{enumerate}

Несмотря на то, что эти интерфейсы имеют между собой мало общего, к ним 
предъявляется ряд общих требований:

\begin{enumerate}
    \item Функциональность -- интерфейс должен отвечать всем требованиям пользователя и соответствовать его задачам.
    \item Логичность -- интерфейс должен быть логичным и запоминающимся, чтобы взаимодействие пользователя
        с программой было как можно более простым и удобным.
    \item Защищенность -- интерфейс должен быть спроектирован таким образом, чтобы у пользователя не было
        возможности совершить ошибку.
\end{enumerate}

После определения общих требований к любому интерфейсу, стоит рассмотреть перечисленные выше
интерфейсы отдельно.

\subsection*{Интерфейс программирования приложений}
\addcontentsline{toc}{subsection}{1.1 Интерфейс программирования приложений}

К интерфейсам программирования приложений можно причислить любой интерфейс, который предназначен для
использования разрабатываемой программы внешними приложениями. Обычно, в зависимости от
используемых технологий, это набор классов, функций или методов, которые используются
внешними программами. В случае данного приложения в качестве интерфейса взаимодействия
было решено использовать веб-технологии. Это означает, что приложение будет взаимодействовать
с любыми своими пользователями через протокол HTTP\cite{RFC2616}.
Таким образом, программный интерфейс приложения будет представлять из себя набор HTTP-методов.

В протоколе HTTP есть несколько видов методов, из которых приложением будут использоваться следующие:

\begin{enumerate}
    \item GET -- это методы, которые запрашивают данные, они не предназначены для их записи.
    \item POST -- это методы, которые используются и для записи данных, и для их получения.
\end{enumerate}

Говоря об HTTP интерфейсах, стоит отметить, что есть несколько различных подходов к их проектированию. 
Одним из наиболее общепринятых подходов является так называемый REST.
Это можно расшифровать как Represental State Transfer\cite{REST}. Данная архитектура предлагает
наложить на приложение ряд следующих ограничений:

\begin{enumerate}
    \item Модель клиент-сервер -- означает, что вся логика должна выполняться на удаленном сервере,
    а клиентское приложение должно исключительно предоставлять и получать данные.
    \item Отсутствие состояния -- сервер получает из запроса всю необходимую информацию и не хранит
    никакую информацию о сессии клиентов.
    \item Кеширование -- сервер сохраняет наиболее частые ответы, что позволяет не выполнять
    лишние запросы к базе данных и соответствующие вычисления, а сразу вернуть результат,
    \item Единообразие интерфейса.
    \item Уровни абстракции -- сокрытие основного сервера за промежуточными. Например, без каких-либо
    изменений для пользователя можно внедрить между ним и сервером промежуточный сервер, который
    предназначен для хранения и возврата хэшированных данных пользователю. В случае отсутствия этих данных
    хэширующий сервер перенаправляет запрос исходному серверу.
\end{enumerate}

Такой подход позволяет добиться лучшей производительности за счет отсутствия состояний между
вызовами и кеширования, а архитектура становится более расширяемой из-за требований
единообразия и выделения уровней абстракции.

\subsection*{Графический интерфейс пользователя}
\addcontentsline{toc}{subsection}{1.2 Графический интерфейс пользователя}

Графический интерфейс пользователя -- это наиболее востребованные интерфейсы в современном мире, потому
что пользователям намного более удобно пользоваться интерфейсами, которые для взаимодействия
с пользователем могут использовать не только текст. 

И, пожалуй, самый популярный вид графических приложений -- это веб-сайты.
Они получили такую популярность из-за своей универсальности: пользователь
может открыть приложение на любом устройстве, на котором есть доступ в интернет
и веб-браузер, в то время как любое другое приложение потребует установки
на устройство пользователя. С другой стороны, веб-сайты очень удобны для
разработчиков. Намного более выгодно разработать одно веб-приложение, чем
создавать и поддерживать несколько программ для разных платформ.

Обычно разработку веб-приложения можно разделить на две части:
<<клиентская>> и <<серверная>>.

Клиентская -- это та часть приложения, которая исполняется в браузере пользователя.
Для написания веб-сайтов используются язык разметки HTML, язык описания стилей CSS и интерпретируемый
язык программирования JavaScript\cite{Web-book}.

Опишем роль каждого языка в веб-приложении:
\begin{enumerate}
    \item HTML -- это каркас всего приложения, который определяет, какие элементы будут использоваться и
    где они будут располагаться,
    \item CSS определяет, как будут выглядеть элементы приложения. Сюда входят, например, внешний вид кнопок
    или вид шрифта отображаемого текста,
    \item JavaScript -- это интерпретируемый язык программирования, основная область применения которого заключается
    в придании интерактивности веб-страницам. Например, динамическую загрузку данных в таблицу можно реализовать только
    через JavaScript. 
    
\end{enumerate}

Серверной обычно называют ту часть приложения, которая стоит за клиентской. В основном это
та программа, которая предоставляет данные, выполняет их хранение и агрегацию. Другими словами,
сервер реализует всю <<бизнес-логику>>, в то время как клиент нужен для предоставления
пользователям доступа к приложению. Более подробно об этом будет рассказано далее.

\subsection*{Интерфейс командной строки}
\addcontentsline{toc}{subsection}{1.3 Интерфейс командной строки}

Интерфейсы командной строки, в отличии от графических и программных интерфейсов, представляют
наименее популярную группу приложений. Но, несмотря на это, они являются
незаменимыми. Главное преимущество приложений командной строки заключается в том, что
ими могут пользоваться в равной степени эффективно человек, и программа. Таким образом,
интерфейсы командной строки являются сочетанием программных и графических интерфейсов:
с одной стороны ими с определенной степенью удобства может пользоваться человек, а с другой
стороны без каких-либо трудностей они могут использоваться для взаимодействия между
приложениями. Также стоит отметить, что приложениям командной строки не нужен какой-либо
графический интерфейс, только окно терминала.

\subsection*{Выбор СУБД}
\addcontentsline{toc}{subsection}{1.4 Выбор СУБД}

База данных является неотъемлемой частью любого приложения, которое выполняет
хранение и обеспечивает работу с информацией. Так что выбор правильной технологии
хранения данных является чрезвычайно важной задачей. 

На текущий момент существует две различные ветви развития систем управления
базами данных(СУБД)\cite{GettingStartedWithNoSQL}: релационная и нереляционная.

Отличительной чертой реляционных баз данных является понятие отношения или таблицы.
Каждая сущность, хранимая в базе данных, должна представлять собой строку таблицы со 
строго заданным типизированным набором столбцов. Также реляционные СУБД гарантируют
выполнение так называемых свойств ACID к транзакционной системе, где под транзакцией
понимается последовательность команд, представляющая логическую единицу работы с данными.
Опишем свойства ACID: 

\begin{enumerate}
	\item Атомарность -- транзация либо будет выполнена целиком, либо
	      не выполнена совсем.
	\item Согласованность -- после выполнения транзакции в базе данных
	      находятся корректные значения.
	\item Изолированность -- на транзакцию не могут оказать влияния другие транзакции,
	      выполняемые параллельно.
	\item Устойчивость -- если транзакция была завершена, то даже при сбое системы
	      изменения будут зафиксированы.
\end{enumerate}

Данные свойства накладывают довольно серьезные ограничения на производительность, что
послужило поводом для появления нереляционных СУБД. Их задачей было
обеспечить хранение данных в высоконагруженных приложениях. В противовес
свойствам ACID, нереляционные базы данных гарантируют выполнение свойств BASE:

\begin{enumerate}
	\item Доступность -- каждый запрос будет выполнен.
	\item Гибкость -- состояние системы может меняться со временем даже без ввода новых данных.
	\item Согласованность в конечном счете -- данные могут быть несогласованы в некоторые
	      моменты времени, но в итоге приходят в согласованное состояние.
\end{enumerate}

Стоит отметить, что существует множество видов нереляционных баз данных, перечислим
основные:

\begin{enumerate}
	\item Документоориентированные -- хранят данные в документах.
	\item Графовые -- хранят данные в виде графа.
	\item ключ-значение -- хранят данные в виде пар вида "ключ-значение".
\end{enumerate}

Так как данные, которые будут храниться в будущем приложении, достаточно просты по своей структуре,
никакого выигрыша от использования графовых баз данных получить не получится.

Базы данных вида ключ-значение также не очень хорошо подходят для поставленной задачи, так как их структура
является слишком простой, так что возникнут дополнительные трудности в работе с такой базой данных.

Таким образом, остаются документоориентированные базы данных. Было решено сравнить реляционные и нереляционные
базы данных на примере PostreSQL и MongoDB.

В основе документоориентированной базы данных лежит понятие документа. В общем случае в качестве формата
может быть множество различных стандартов: JSON, XML, YAML и так далее. В случае MongoDB для хранения
используется BSON\cite{MongoDBDocs} -- бинарное надмножество JSON. В данной СУБД документы группируются в так называемые
коллекции. В отличии от реляционной модели, коллекция не имеет какой-либо строгой структуры. То есть
в ней могут храниться абсолютно разные документы.

Данных подход имеет ряд своих преимуществ и недостатков. Перечислим положительные стороны:

\begin{enumerate}
	\item Гибкость -- так как коллекция не ограничена структурой хранимых данных, информация
	      в ней может несколько отличаться от записи к записи. Это может быть полезно, если
	      данные имеют в целом общий смысл, но в некоторых документах могут присутствовать
	      какие-то особые поля.
	\item Производительность -- так как не происходит никаких проверок, запись и чтение
	      работают существенно быстрее, чем в реляционном подходе.
\end{enumerate}

Недостатки и ограничения:

\begin{enumerate}
	\item Подобная организация плохо подходит для создание ссылок между объектами по, например,
	      первичному ключу. Это связано с описанным выше отсутствием проверок. Канонический
	      способ хранения данных -- это использование вложенных документов. Но этот способ
	      применим не везде из-за ограничения на размер документа в 16 МБ.
	\item Как было описано в пункте выше, довольно сложно производить нормализацию
	      данных, потому что все проверки необходимо производить не на уровне СУБД, а
	      на уровне приложения.
\end{enumerate}

Теперь стоит проанализировать данные, которые будут храниться в приложении.

Все данные имеют абсолютно строгую структуру. Если говорить о хранимых книгах, то для них есть набор полей, определенный
стандартом BibTeX, который обязан быть у каждой записи. Остальные данные, такие как списки литературы
и учебные курсы, также не имеют никакой вариативности. Таким образом, гибкость NoSQL подхода только 
добавит сложностей в связи с необходимостю ручной реализации множества проверок.

Конечная цель приложения -- генерировать списки литературы
для учебных курсов. И весьма логичным требованием будет то, что в любой момент времени приложение
должно генерировать корректные отчеты. Таким образом, для данной задачи больше подходят требования
ACID, чем BASE.

Как видно из рассуждений выше, несмотря на все свои преимущества, для поставленной задачи больше
подходит реляционная модель.
